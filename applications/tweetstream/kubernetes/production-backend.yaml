apiVersion: v1
kind: ConfigMap
metadata:
  name: tweetstream-prod-init
  namespace: default
data:
  init-db.sh: |
    #!/bin/sh
    set -e
    
    echo "ğŸ”§ Initializing TweetStream Database..."
    
    # Wait for PostgreSQL
    until pg_isready -h $DB_HOST -p $DB_PORT -U $DB_USER; do
      echo "â³ Waiting for PostgreSQL..."
      sleep 3
    done
    
    echo "âœ… PostgreSQL is ready"
    
    # Check if database exists and create if needed
    if PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -c "SELECT 1;" > /dev/null 2>&1; then
      echo "âœ… Database $DB_NAME already exists"
    else
      echo "ğŸ“Š Creating database: $DB_NAME"
      PGPASSWORD=$DB_PASSWORD createdb -h $DB_HOST -p $DB_PORT -U $DB_USER $DB_NAME || echo "Database might already exist, continuing..."
    fi
    
    # Apply schema
    echo "ğŸ—ï¸ Applying schema..."
    PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME << 'EOF'
    -- Create tables if they don't exist
    CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(255) UNIQUE NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        display_name VARCHAR(100) NOT NULL,
        bio TEXT,
        avatar_url VARCHAR(500),
        verified BOOLEAN DEFAULT FALSE,
        followers_count INTEGER DEFAULT 0,
        following_count INTEGER DEFAULT 0,
        tweets_count INTEGER DEFAULT 0,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS tweets (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        content TEXT NOT NULL,
        image_url VARCHAR(500),
        likes_count INTEGER DEFAULT 0,
        retweets_count INTEGER DEFAULT 0,
        replies_count INTEGER DEFAULT 0,
        reply_to_id INTEGER REFERENCES tweets(id) ON DELETE CASCADE,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        CONSTRAINT content_length CHECK (char_length(content) <= 280)
    );

    CREATE TABLE IF NOT EXISTS follows (
        id SERIAL PRIMARY KEY,
        follower_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        following_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(follower_id, following_id),
        CHECK (follower_id != following_id)
    );

    CREATE TABLE IF NOT EXISTS likes (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        tweet_id INTEGER NOT NULL REFERENCES tweets(id) ON DELETE CASCADE,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id, tweet_id)
    );

    CREATE TABLE IF NOT EXISTS retweets (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        tweet_id INTEGER NOT NULL REFERENCES tweets(id) ON DELETE CASCADE,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id, tweet_id)
    );

    CREATE TABLE IF NOT EXISTS notifications (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        type VARCHAR(50) NOT NULL,
        from_user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
        tweet_id INTEGER REFERENCES tweets(id) ON DELETE CASCADE,
        message TEXT,
        read BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );

    -- Create indexes
    CREATE INDEX IF NOT EXISTS idx_tweets_user_id ON tweets(user_id);
    CREATE INDEX IF NOT EXISTS idx_tweets_created_at ON tweets(created_at DESC);
    CREATE INDEX IF NOT EXISTS idx_follows_follower_id ON follows(follower_id);
    CREATE INDEX IF NOT EXISTS idx_follows_following_id ON follows(following_id);
    CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
    CREATE INDEX IF NOT EXISTS idx_likes_user_id ON likes(user_id);
    CREATE INDEX IF NOT EXISTS idx_likes_tweet_id ON likes(tweet_id);
    EOF
    
    # Insert sample data only if users table is empty
    USER_COUNT=$(PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -t -c "SELECT COUNT(*) FROM users;" | tr -d ' ')
    if [ "$USER_COUNT" = "0" ]; then
      echo "ğŸ“ Inserting sample data..."
      PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME << 'EOF'
      INSERT INTO users (username, email, password_hash, display_name, bio, verified) VALUES
      ('john_doe', 'john@example.com', '$2a$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj/VcSAg/9qK', 'John Doe', 'TypeScript Backend Developer ğŸš€', false),
      ('jane_smith', 'jane@example.com', '$2a$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj/VcSAg/9qK', 'Jane Smith', 'Product Manager | Building the future âœ¨', true),
      ('tech_guru', 'tech@example.com', '$2a$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj/VcSAg/9qK', 'Tech Guru', 'Full-stack developer with PostgreSQL expertise', false);
      
      INSERT INTO tweets (user_id, content, likes_count, retweets_count) VALUES
      (1, 'Hello from the new TypeScript backend! ğŸš€ Real database integration working perfectly!', 15, 7),
      (2, 'Amazing performance with PostgreSQL and Redis caching! ğŸ’ª', 23, 12),
      (3, 'Socket.IO + Kafka real-time updates are incredible! âš¡', 18, 9);
    EOF
    else
      echo "âœ… Sample data already exists"
    fi
    
    echo "âœ… Database initialization complete!"

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tweetstream-production
  namespace: default
  labels:
    app: tweetstream-production
    version: typescript
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tweetstream-production
  template:
    metadata:
      labels:
        app: tweetstream-production
        version: typescript
    spec:
      initContainers:
      - name: db-init
        image: postgres:15-alpine
        env:
        - name: DB_HOST
          value: "10.110.47.87"  # Direct PostgreSQL IP
        - name: DB_PORT
          value: "5432"
        - name: DB_NAME
          value: "tweetstream"
        - name: DB_USER
          value: "postgres"
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-credentials
              key: password
        - name: PGPASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-credentials
              key: password
        command: ["/bin/sh"]
        args: ["/scripts/init-db.sh"]
        volumeMounts:
        - name: init-script
          mountPath: /scripts
      containers:
      - name: backend
        image: node:18-alpine
        workingDir: /app
        ports:
        - containerPort: 5000
        env:
        - name: NODE_ENV
          value: "production"
        - name: PORT
          value: "5000"
        - name: DB_HOST
          value: "10.110.47.87"  # Direct PostgreSQL IP
        - name: DB_PORT
          value: "5432"
        - name: DB_NAME
          value: "tweetstream"
        - name: DB_USER
          value: "postgres"
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-credentials
              key: password
        - name: REDIS_HOST
          value: "redis-master.platform-services.svc.cluster.local"
        - name: REDIS_PORT
          value: "6379"
        - name: KAFKA_BROKER
          value: "kafka.platform-services.svc.cluster.local:9092"
        - name: JWT_SECRET
          value: "tweetstream-jwt-secret-typescript-production"
        - name: JWT_EXPIRES_IN
          value: "7d"
        - name: FRONTEND_URL
          value: "http://sanzad-ubuntu-21:30951"
        command:
        - /bin/sh
        - -c
        - |
          echo "ğŸš€ Building TweetStream TypeScript Backend..."
          
          # Copy source files
          cp -r /app-src/* ./
          
          # Install ALL dependencies (including dev for TypeScript)
          npm install
          
          echo "ğŸ”¨ Building TypeScript..."
          npx tsc
          
          echo "ğŸŒŸ Starting Production Backend..."
          node dist/server.js
        volumeMounts:
        - name: app-source
          mountPath: /app-src
        - name: package-config
          mountPath: /app/package.json
          subPath: package.json
        - name: ts-config
          mountPath: /app/tsconfig.json
          subPath: tsconfig.json
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
      volumes:
      - name: init-script
        configMap:
          name: tweetstream-prod-init
          defaultMode: 0755
      - name: app-source
        configMap:
          name: tweetstream-ts-source
      - name: package-config
        configMap:
          name: tweetstream-ts-config
          items:
          - key: package.json
            path: package.json
      - name: ts-config
        configMap:
          name: tweetstream-ts-config
          items:
          - key: tsconfig.json
            path: tsconfig.json

---
apiVersion: v1
kind: Service
metadata:
  name: tweetstream-production-service
  namespace: default
  labels:
    app: tweetstream-production
spec:
  type: NodePort
  ports:
  - port: 5000
    targetPort: 5000
    nodePort: 30955
    protocol: TCP
    name: http
  selector:
    app: tweetstream-production

---
# Note: Create the secret manually before deploying:
# kubectl create secret generic postgres-credentials --from-literal=password=YOUR_PASSWORD 